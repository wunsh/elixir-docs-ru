---
title: GenServer
---

В [предыдущей главе](/getting-started/mix-otp/agent.html) мы использовали агенты (agents), чтобы представить наши корзины (buckets). В первой главе мы указали имя каждой корзины, поэтому мы можем сделать следующее:

```elixir
CREATE shopping
OK

PUT shopping milk 1
OK

GET shopping milk
1
OK
```

Поскольку агенты - процессы, каждая корзина имеет идентификатор процесса (PID), но не имеет названия. Мы узнали о регистрации имени [в главе Процессы](/getting-started/processes.html) и вы могли бы решить эту проблему с помощью такой регистрации. Например, мы могли бы создать корзину так:

```elixir
iex> Agent.start_link(fn -> %{} end, name: :shopping)
{:ok, #PID<0.43.0>}
iex> KV.Bucket.put(:shopping, "milk", 1)
:ok
iex> KV.Bucket.get(:shopping, "milk")
1
```

Тем не менее, это ужасная идея! Имена Процессов в Эликсире должны быть атомами, это означает, что мы должны преобразовать имя корзины (часто получаемое из внешнего клиента) в атомы, **мы никогда не должны преобразовывать ввод пользователя в атомы**. Сборщик мусора не уничтожает атомы.Генерация атомов из пользовательского ввода может привести к исчерпанию Системной памяти!

На практике, скорее всего, вы достигнете предела максимального количества атомов для Виртуальной Машины Эрланга, и ваша система упадет в любом случае.

Вместо того, чтобы злоупотреблять регистрацией имени объекта, мы создадим процесс регистрации, который содержит словарь, который связывает имя корзины с процессом корзины.

Регистрация должна гарантировать, что словарь постоянно обновляется. Например, если один из процессов падает из-за ошибки в реестре, вы должны очистить словарь для того, чтобы избежать обслуживания устаревших записей. В эликсир, мы обосновываем это тем, что реестр должен контролировать каждую корзину.

Мы будем использовать [GenServer](https://hexdocs.pm/elixir/GenServer.html) для создания реестра процессов, который может следить за корзиной процессов. GenServer обеспечивает промышленную мощь, функциональность для создания сервера в эликсир и <abbr title="Open Telecom Platform">ОТП</abbr>.

## Наш первый GenServer

GenServer состоит из двух частей: клиентского API и вызовов сервера. Вы можете либо объединить обе части в один модуль, либо вы можете разделить их на клиентский модуль и модуль сервера. Клиент и сервер работают в отдельных процессах, клиент передает сообщения обратно на сервер, как его функции. Мы будем использовать один модуль для обратных вызовов сервера и API клиента.

Создайте новый файл lib/kv/registry.ex со следующим содержимым:

```elixir
defmodule KV.Registry do
  use GenServer

  ## Client API

  @doc """
  Starts the registry.
  """
  def start_link do
    GenServer.start_link(__MODULE__, :ok, [])
  end

  @doc """
  Looks up the bucket pid for `name` stored in `server`.

  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.
  """
  def lookup(server, name) do
    GenServer.call(server, {:lookup, name})
  end

  @doc """
  Ensures there is a bucket associated to the given `name` in `server`.
  """
  def create(server, name) do
    GenServer.cast(server, {:create, name})
  end

  ## Server Callbacks

  def init(:ok) do
    {:ok, %{}}
  end

  def handle_call({:lookup, name}, _from, names) do
    {:reply, Map.fetch(names, name), names}
  end

  def handle_cast({:create, name}, names) do
    if Map.has_key?(names, name) do
      {:noreply, names}
    else
      {:ok, bucket} = KV.Bucket.start_link
      {:noreply, Map.put(names, name, bucket)}
    end
  end
end
```

Первая функция `start_link/3`, которая запускает GenServer, передает три аргумента:

1. Модуль, где сервер обратных вызовов реализован, в нашем случае `__MODULE__`, значение текущего модуля

2. Аргументы инициализации, в нашем случае атом `:ok`

3. Список параметров, которые могут использоваться, чтобы определить такие вещи, как имя сервера. Сейчас мы передаем пустой список

Есть два типа запросов, которые вы можете отправить GenServer: синхронные вызовы(calls) и асинхронные вызовы(casts). Если вызовы являются синхронными, сервер **должен** отправить ответ на такие запросы. Если вызовы являются асинхронными, сервер не посылает ответ обратно.

Следующие две функции, `lookup/2` и `create/2`, несут ответственность за отправку этих запросов к серверу. В данном случае, мы воспользовались `{:lookup, name}` и `{:create, name}` соответственно. Запрос часто указывается в качестве кортежа, для того, чтобы обеспечить несколько “аргументов” в слоте. Как правило, чтобы указать действие используют первый элемент кортежа, оставшиеся элементы являются аргументами. Обратите внимание, что запросы должны соответствовать первым аргументом handle_call/3 или handle_cast/2.

Это клиентский API. На стороне сервера мы можем реализовать различные обратные вызовы, чтобы гарантировать инициализацию сервера, обработку запросов и прекращение работы сервера. Эти обратные вызовы являются необязательными и сейчас мы реализовали только то, что нас интересует.

Первый - это `init/1`, обратный вызов, который получает второй аргумент `GenServer.start_link/3` и возвращает `{:ok, state}`, где состояние представляет собой новый словарь. Мы уже можем заметить, что `GenServer` API делает разделение на части клиент/сервер более очевидным. `start_link/3` происходит на клиенте, а `init/1` это соответствует обратному вызову, который выполняется на сервере.

Для `call/2` запросов мы реализуем обратный вызов `handle_call/3`, который получает `request`, процесс, от которого мы получили запрос (`_from`) и текущее состояние сервера (`names`). В `handle_call/3` обратный вызов возвращает кортеж в формате `{:reply, reply, new_state}`. Первый элемент кортежа, `:reply`, указывает, что сервер должен отправлять ответ обратно клиенту. Второй элемент `reply` - это то, что будет отправлено клиенту, а третий элемент, `new_state`, это новое состояние сервера.

Для `cast/2` запросов мы реализуем обратный вызов `handle_cast/2`, который получает `request` и текущее состояние сервера (`names`). В `handle_cast/2` обратный вызов возвращает кортеж в формате `{:noreply, new_state}`. Обратите внимание, что в реальном приложении мы бы, наверное, реализовали обратный вызов `:create` с синхронным вызовом вместо асинхронного вызова. Мы делаем это таким образом, чтобы проиллюстрировать, как реализовать асинхронный вызов.

Есть и другие форматы кортежей для `handle_call/3` и `handle_cast/2`, которые обратные вызовы могут возвратить. Так же есть и другие обратные вызовы, такие как `terminate/2` и `code_change/3`, мы могли бы реализовать их. Вы можете изучить [полную документацию GenServer](https://hexdocs.pm/elixir/GenServer.html), чтобы узнать больше о них.

Теперь давайте напишем несколько тестов, чтобы гарантировать, что наш GenServer работает, как ожидалось.

## Тестирование GenServer

Тестирование GenServer не сильно отличается от тестирования агента. Мы создадим сервер в настройках обратного вызова и будем использовать его во время наших тестов. Создайте файл test/kv/registry_test.exs со следующим содержимым:

```elixir
defmodule KV.RegistryTest do
  use ExUnit.Case, async: true

  setup do
    {:ok, registry} = KV.Registry.start_link
    {:ok, registry: registry}
  end

  test "spawns buckets", %{registry: registry} do
    assert KV.Registry.lookup(registry, "shopping") == :error

    KV.Registry.create(registry, "shopping")
    assert {:ok, bucket} = KV.Registry.lookup(registry, "shopping")

    KV.Bucket.put(bucket, "milk", 1)
    assert KV.Bucket.get(bucket, "milk") == 1
  end
end
```

Наш тест должен выполниться без ошибок прямо из коробки!

Нам не нужно явно закрывать реестр, потому что он будет получать сигнал `:shutdown`, когда наш тест заканчивается. При этом такое решение хорошо для тестов, если есть необходимость остановить `GenServer` как часть логики приложения, можно использовать функцию `GenServer.stop/1`:

```elixir
## Client API

@doc """
Stops the registry.
"""
def stop(server) do
  GenServer.stop(server)
end
```

## Необходимость мониторинга

Наш реестр почти готов. Единственный оставшийся вопрос заключается в том, что реестр может стать неактуальным, если корзина останавливается или падает. Давайте добавим тест `KV.RegistryTest`, который выявляет эту ошибку:

```elixir
test "removes buckets on exit", %{registry: registry} do
  KV.Registry.create(registry, "shopping")
  {:ok, bucket} = KV.Registry.lookup(registry, "shopping")
  Agent.stop(bucket)
  assert KV.Registry.lookup(registry, "shopping") == :error
end
```

Этот тест упадет, так как имя корзины остается в реестре даже после прекращения процесса.

Для того, чтобы исправить эту ошибку, нам нужно зарегистровать монитор, когда корзина создается. Как только мы установим монитор, реестр будет получать уведомления каждый раз, когда корзина заканчивает работу, позволяющие очистить словарь.

Давайте поиграем с мониторами, запустив новую консоль с параметрами `iex ‐S mix`:

```elixir
iex> {:ok, pid} = KV.Bucket.start_link
{:ok, #PID<0.66.0>}
iex> Process.monitor(pid)
#Reference<0.0.0.551>
iex> Agent.stop(pid)
:ok
iex> flush()
{:DOWN, #Reference<0.0.0.551>, :process, #PID<0.66.0>, :normal}
```

Обратите внимание, `Process.monitor(pid)` возвращает уникальную ссылку, что позволяет нам мониторить выходящие сообщения процесса. После того, как мы остановили агента, мы можем  при помощи `flush/0` посмотреть все консольные сообщения и обратите внимание, что `:DOWN` сообщение прибыло, с точной ссылкой, возвращенной монитором, указывающией, что процесс завершен корзиной с причиной `:normal`.

Давайте переопределим коллбэки сервера, чтобы исправить баг и пройдем тест. Во-первых, мы изменим состояние GenServer используя два словаря: один будет содержать `name ‐> pid`, а другой - `ref ‐> name`. Затем нам нужно мониторить корзины при помощи `handle_cast/2`, а также реализовать функцию коллбэков `handle_info/2`  для обработки мониторинга Сообщений. Полное выполнение коллбэков сервера показано ниже:

```elixir
## Server callbacks

def init(:ok) do
  names = %{}
  refs  = %{}
  {:ok, {names, refs}}
end

def handle_call({:lookup, name}, _from, {names, _} = state) do
  {:reply, Map.fetch(names, name), state}
end

def handle_cast({:create, name}, {names, refs}) do
  if Map.has_key?(names, name) do
    {:noreply, {names, refs}}
  else
    {:ok, pid} = KV.Bucket.start_link
    ref = Process.monitor(pid)
    refs = Map.put(refs, ref, name)
    names = Map.put(names, name, pid)
    {:noreply, {names, refs}}
  end
end

def handle_info({:DOWN, ref, :process, _pid, _reason}, {names, refs}) do
  {name, refs} = Map.pop(refs, ref)
  names = Map.delete(names, name)
  {:noreply, {names, refs}}
end

def handle_info(_msg, state) do
  {:noreply, state}
end
```

Заметим, что нам удалось значительно изменить реализацию сервера без изменения каких-либо API клиента. Это одно из преимуществ четкого разделения на серверную и клиентскую части.

Наконец, в отличие от других обратных вызовов, мы определили положение “поймать-все” для функции `handle_info/2` которая удаляет любые подозрительные сообщения. Чтобы понять, почему мы это сделали, давайте перейдем к следующему разделу.

## `call`, `cast` или `info`?

До сих пор мы воспользовались тремя коллбэками: `handle_call/3`, `handle_cast/2` и `handle_info/2`. Вот, что мы должны учитывать при принятии решения, когда следует использовать каждый:

1. `handle_call/3` должен быть использован для синхронных запросов. Он должен быть выбором по умолчанию в ожидании ответа сервера и является полезным механизмом противодавления.

2. `handle_cast/2` должен быть использован для асинхронных запросов, когда ты не заботишься об ответе. Бросок не дает гарантии что сервер получил сообщение и, по этой причине, его следует использовать с осторожностью. Например, функция `create/2`, которую мы определили в этой главе, должна использовать `call/2`. Мы использовали `cast/2` для обучающих целей.

3. `handle_info/2` должен использоваться для всех других сообщений, которые сервер может получать и не передаются через `GenServer.call/2` или `GenServer.cast/2`, включая регулярные сообщения `send/2`. Мониторинг cообщений `:DOWN` - как раз такой пример.

Так как любое сообщение, в том числе направленное через `send/2`, идет на `handle_info/2`, есть шанс, что неожиданные сообщения будут поступать на сервер. Поэтому, если мы не определим общее положение, эти сообщения могут привести наш реестр к краху, потому что ни один пункт не будет им соответствовать. Нам не нужно беспокоиться о таких случаях с `handle_call/3` и `handle_cast/2`. Вызовы и броски могут проходить только через `GenServer` API, поэтому неизвестное сообщение вероятно произойдет из-за ошибки разработчика.

Чтобы помочь разработчикам помнить различия между вызовом, броском и info, поддерживаемыми возвращаемыми значениями и т. Д., [Бенджамин Тан Вэй Хао](http://benjamintan.io) создал отличный [чит-лист GenServer](https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf).

## Мониторы или ссылки

Ранее мы узнали о связях в [главе Процессы](/getting-started/processes.html). Теперь, с полным завершением реестра, вам может быть интересно: когда мы должны использовать мониторы и когда следует использовать ссылки?

Ссылки двунаправлены. Если вы связываете два процесса, и один из них выйдет из строя, другая сторона тоже выйдет из строя (если только это не установлен флаг trapping exits true). Монитор является однонаправленным: процесс мониторинга будет только получать уведомления о контролируемом. Другими словами: используйте ссылки, когда вы хотите получить связанные сбои, и мониторьте процессы, когда вы просто хотите получать информацию о сбоях, выходах и т.д.

Возвращаясь к нашей реализации `handle_cast/2`, вы можете видеть, что реестр является как связующим, так и контролирующим корзины:

```elixir
{:ok, pid} = KV.Bucket.start_link
ref = Process.monitor(pid)
```

Это плохая идея, так как мы не хотим, чтобы реестр падал при сбое корзины! Мы обычно избегаем непосредственного создания новых процессов, вместо этого мы делегируем эту ответственность супервизорам. Как мы увидим в следующей главе, супервизеры полагаются на ссылки, и это объясняет, почему API-интерфейсы на основе ссылок (`spawn_link`, `start_link` т. д.) настолько распространены в Эликсире и <abbr title="Открытая Телекомуникационная Платформа">ОТП</abbr>.
